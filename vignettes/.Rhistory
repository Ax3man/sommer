############################
# real G and P for later use
G0 <- varG(pop)
P0 <- varP(pop)
G0%*%solve(P0) # multivariate heritability
########################################################
# make a dataset with the phenotypes for the mixed model
DT <- pop@pheno
colnames(DT) <- c("Yield","color")
DT <- data.frame(id=pop@id, DT)
head(DT)
M <- pullQtlGeno(pop, simParam=SP)
A <- A.mat(M-1)
##########################################################
# fit the mixed model but force the variance components to be the true ones since
# estimation would yield different variance covariance components leading to different merits
# because of estimation errors due to sample size, etc.
# sommer takes scaled values as initial variance components
scaledDiagsG0 <- G0/P0; # get scaled diagonals
G0scaled <- cov(scale(pop@gv))/2 # get scaled off-diagonals
diag(G0scaled) <- diag(scaledDiagsG0) # form only one matrix
E0scaled <- cov(scale(pop@pheno)) - G0scaled
mix1 <- mmer(cbind(Yield,color)~1,
random=~vs(id, Gtc=fixm(2),Gti=G0scaled),
rcov=~vs(units, Gtc=fixm(2), Gti=E0scaled),
iters = 1,
data=DT)
mix1$sigma$`u:id`;G0 # should be equal
mix1$sigma$`u:id` + mix1$sigma$`u:units`; P0 # should be equal
mix1$sigma$`u:id`;G0 # should be equal
mix1$sigma$`u:id` + mix1$sigma$`u:units`; P0 # should be equal
mix1$sigma$`u:units`
mix1$sigma$`u:id`
mix1$sigma$`u:id`;G0 # should be equal
mix1$sigma$`u:id` + mix1$sigma$`u:units`; P0 # should be equal
# estimated P and G
G <- mix1$sigma$`u:id`
P <- var(DT[,2:3])
############################################
# ECONOMIC WEIGHTS
w <- c(2,1) # original economic weights
# merit using raw phenotypes multiplied by v = P-Gw
# D*v
merit1 <- pop@pheno %*% smithHazel(w,G0,P0)
# merit using multivariate BLUPs times original weights
# U*w
ids <- as.character(DT$id)
U <- cbind(mix1$U$`u:id`$Yield[ids]+mix1$Beta$Estimate[1],mix1$U$`u:id`$color[ids]+mix1$Beta$Estimate[2])
merit2 <- U %*% w
# compare them, as a result merit  D*v = B*w
plot(merit1,merit2)
scaledDiagsG0
##########################################################
# fit the mixed model but force the variance components to be the true ones since
# estimation would yield different variance covariance components leading to different merits
# because of estimation errors due to sample size, etc.
# sommer takes scaled values as initial variance components
scaledDiagsG0 <- G0/P0; # get scaled diagonals
G0scaled <- cov(scale(pop@gv))/4 # get scaled off-diagonals
diag(G0scaled) <- diag(scaledDiagsG0) # form only one matrix
E0scaled <- cov(scale(pop@pheno)) - G0scaled
mix1 <- mmer(cbind(Yield,color)~1,
random=~vs(id, Gtc=fixm(2),Gti=G0scaled),
rcov=~vs(units, Gtc=fixm(2), Gti=E0scaled),
iters = 1,
data=DT)
mix1$sigma$`u:id`;G0 # should be equal
G0scaled <- cov(scale(pop@gv))/1 # get scaled off-diagonals
diag(G0scaled) <- diag(scaledDiagsG0) # form only one matrix
E0scaled <- cov(scale(pop@pheno)) - G0scaled
mix1 <- mmer(cbind(Yield,color)~1,
random=~vs(id, Gtc=fixm(2),Gti=G0scaled),
rcov=~vs(units, Gtc=fixm(2), Gti=E0scaled),
iters = 1,
data=DT)
mix1$sigma$`u:id`;G0 # should be equal
6.81/1.12
G0scaled <- cov(scale(pop@gv))/6.08 # get scaled off-diagonals
diag(G0scaled) <- diag(scaledDiagsG0) # form only one matrix
E0scaled <- cov(scale(pop@pheno)) - G0scaled
mix1 <- mmer(cbind(Yield,color)~1,
random=~vs(id, Gtc=fixm(2),Gti=G0scaled),
rcov=~vs(units, Gtc=fixm(2), Gti=E0scaled),
iters = 1,
data=DT)
mix1$sigma$`u:id`;G0 # should be equal
mix1$sigma$`u:id` + mix1$sigma$`u:units`; P0 # should be equal
# estimated P and G
G <- mix1$sigma$`u:id`
P <- var(DT[,2:3])
############################################
# ECONOMIC WEIGHTS
w <- c(2,1) # original economic weights
# merit using raw phenotypes multiplied by v = P-Gw
# D*v
merit1 <- pop@pheno %*% smithHazel(w,G0,P0)
# merit using multivariate BLUPs times original weights
# U*w
ids <- as.character(DT$id)
U <- cbind(mix1$U$`u:id`$Yield[ids]+mix1$Beta$Estimate[1],mix1$U$`u:id`$color[ids]+mix1$Beta$Estimate[2])
merit2 <- U %*% w
# compare them, as a result merit  D*v = B*w
plot(merit1,merit2)
U <- cbind(mix1$U$`u:id`$Yield[ids],mix1$U$`u:id`$color[ids])
merit2 <- U %*% w
# compare them, as a result merit  D*v = B*w
plot(merit1,merit2)
# merit using multivariate BLUPs times original weights
# U*w
ids <- as.character(DT$id)
U <- cbind(mix1$U$`u:id`$Yield[ids]+mix1$Beta$Estimate[1],mix1$U$`u:id`$color[ids]+mix1$Beta$Estimate[2])
merit2 <- U %*% w
# compare them, as a result merit  D*v = B*w
plot(merit1,merit2)
mix1$sigma$`u:id` + mix1$sigma$`u:units`; P0 # should be equal
d <- sqrt(diag(G0)) # original desired gains (1 standard deviation)
w <- solve(G0)%*%d # desired weights Ginv*d, equivalent to knowing w (economic weights)
# merit using raw phenotypes multiplied by v = P-Gw
# D*v
merit1 <- pop@pheno %*% w # in reality we don't know G0 and phenotype matrix has more than one record per individual, so this is not possible
# merit using multivariate BLUPs times desired weights
# U.dereg*w
ids <- as.character(DT$id)
U <- cbind(mix1$U$`u:id`$Yield[ids]+mix1$Beta$Estimate[1],mix1$U$`u:id`$color[ids]+mix1$Beta$Estimate[2])
U.dereg <- (P0%*%solve(G0)) %*% t(U)
merit2 <- U %*% w
merit3 <- t(U.dereg) %*% w
# compare them, as a result merit  D*v = B*w
plot(merit1,merit2)
plot(merit1,merit3)
(P0%*%solve(G0))
d
w
1/d
G0scaled
mixt1 <- mmer(Yield~1,
random=~vs(id, Gtc=fixm(1),Gti=G0scaled[1,1]),
rcov=~vs(units, Gtc=fixm(1), Gti=E0scaled[1,1]),
iters = 1,
data=DT)
mixt1 <- mmer(Yield~1,
random=~vs(id, Gtc=fixm(1),Gti=matrix(G0scaled[1,1])),
rcov=~vs(units, Gtc=fixm(1), Gti=matrix(E0scaled[1,1])),
iters = 1,
data=DT)
mixt2 <- mmer(color~1,
random=~vs(id, Gtc=fixm(1),Gti=matrix(G0scaled[2,2])),
rcov=~vs(units, Gtc=fixm(1), Gti=matrix(E0scaled[2,2])),
iters = 1,
data=DT)
d <- sqrt(diag(G0)) # original desired gains (1 standard deviation), response to selection desired
w <- solve(G0)%*%d # desired weights Ginv*d, equivalent to knowing w (economic weights)
# merit using raw phenotypes multiplied by v = P-Gw
# D*v
merit1 <- pop@pheno %*% w # in reality we don't know G0 and phenotype matrix has more than one record per individual, so this is not possible
# merit using multivariate BLUPs times desired weights
# U.dereg*w
ids <- as.character(DT$id)
mixt2$Beta$Estimate
U <- cbind(mixt1$U$`u:id`$Yield[ids]+mixt1$Beta$Estimate[1],mixt2$U$`u:id`$color[ids]+mixt2$Beta$Estimate[1])
head(U)
G0u <- cov(U)
G0
G0u
mixt1$sigma$`u:id`
mixt2$sigma$`u:id`
U <- cbind(mixt1$U$`u:id`$Yield[ids],mixt2$U$`u:id`$color[ids])
G0u <- cov(U)
G0u
G0u
pairs(U)
G0u
mixt1$sigma$`u:id`
G0u[1,1] <- mixt1$sigma$`u:id`
G0u[2,2] <- mixt2$sigma$`u:id`
d <- sqrt(diag(G0u)) # original desired gains (1 standard deviation), response to selection desired
w <- solve(G0u)%*%d # desired weights Ginv*d, equivalent to knowing w (economic weights)
w
U <- cbind(mixt1$U$`u:id`$Yield[ids]+mixt1$Beta$Estimate[1],mixt2$U$`u:id`$color[ids]+mixt2$Beta$Estimate[1])
G0u <- cov(U)
G0u[1,1] <- mixt1$sigma$`u:id`
G0u[2,2] <- mixt2$sigma$`u:id`
d <- sqrt(diag(G0u)) # original desired gains (1 standard deviation), response to selection desired
w <- solve(G0u)%*%d # desired weights Ginv*d, equivalent to knowing w (economic weights)
d
w
# merit using raw phenotypes multiplied by v = P-Gw
# D*v
merit1 <- pop@pheno %*% w # in reality we don't know G0 and phenotype matrix has more than one record per individual, so this is not possible
# merit using multivariate BLUPs times desired weights
# U.dereg*w
ids <- as.character(DT$id)
U.dereg <- (P0%*%solve(G0u)) %*% t(U)
merit2 <- U %*% w
merit3 <- t(U.dereg) %*% w
# compare them, as a result merit  D*v = B*w
plot(merit1,merit2)
plot(merit1,merit3)
G0u
############################################
# ECONOMIC WEIGHTS
w <- c(2,1) # original economic weights
# merit using raw phenotypes multiplied by v = P-Gw
# D*v
merit1 <- pop@pheno %*% smithHazel(w,G0,P0)
# merit using multivariate BLUPs times original weights
# U*w
ids <- as.character(DT$id)
U <- cbind(mix1$U$`u:id`$Yield[ids]+mix1$Beta$Estimate[1],mix1$U$`u:id`$color[ids]+mix1$Beta$Estimate[2])
merit2 <- U %*% w
# compare them, as a result merit  D*v = B*w
plot(merit1,merit2)
d <- sqrt(diag(G0)) # original desired gains (1 standard deviation), response to selection desired
w <- solve(G0)%*%d # desired weights Ginv*d, equivalent to knowing w (economic weights)
# merit using raw phenotypes multiplied by v = P-Gw
# D*v
merit1 <- pop@pheno %*% w # in reality we don't know G0 and phenotype matrix has more than one record per individual, so this is not possible
# merit using multivariate BLUPs times desired weights
# U.dereg*w
ids <- as.character(DT$id)
U <- cbind(mix1$U$`u:id`$Yield[ids]+mix1$Beta$Estimate[1],mix1$U$`u:id`$color[ids]+mix1$Beta$Estimate[2])
U.dereg <- (P0%*%solve(G0)) %*% t(U)
merit2 <- U %*% w
merit3 <- t(U.dereg) %*% w
# compare them, as a result merit  D*v = B*w
plot(merit1,merit2)
plot(merit1,merit3)
cov2cor(G0)
?runMacs2
Gnull <- matrix(-0.6,2) + diag(1.6,2)
Gnull <- matrix(-0.6,2,2) + diag(1.6,2,2)
Gnull
############################
# simulate a population
# create the founder population
founderPop = runMacs2(nInd=1000,nChr=1,segSites=1000)
#Set simulation parameters
SP = SimParam$new(founderPop)
SP$addSnpChip(100)
SP = SimParam$new(founderPop)
# SP$addTraitA(50,200,10) # trait 1
# SP$addTraitA(50,10,2) # trait 2
# or
Gnull <- matrix(-0.6,2,2) + diag(1.6,2,2)
SP$addTraitA(50,mean = c(200,10),var = c(10,2), corA = Gnull) # trait 1
# create the population
pop <- newPop(founderPop)
# set phenotypes with h2=0.5
pop = setPheno(pop, varE=diag(varG(pop))*5)
############################
# real G and P for later use
G0 <- varG(pop)
P0 <- varP(pop)
G0%*%solve(P0) # multivariate heritability
G0
P0
G0%*%solve(P0) # multivariate heritability
cov2cor(G0)
########################################################
# make a dataset with the phenotypes for the mixed model
DT <- pop@pheno
colnames(DT) <- c("Yield","color")
DT <- data.frame(id=pop@id, DT)
head(DT)
M <- pullQtlGeno(pop, simParam=SP)
A <- A.mat(M-1)
##########################################################
# fit the mixed model but force the variance components to be the true ones since
# estimation would yield different variance covariance components leading to different merits
# because of estimation errors due to sample size, etc.
# sommer takes scaled values as initial variance components
scaledDiagsG0 <- G0/P0; # get scaled diagonals
G0scaled <- cov(scale(pop@gv))/6.08 # get scaled off-diagonals
diag(G0scaled) <- diag(scaledDiagsG0) # form only one matrix
E0scaled <- cov(scale(pop@pheno)) - G0scaled
mix1 <- mmer(cbind(Yield,color)~1,
random=~vs(id, Gtc=fixm(2),Gti=G0scaled),
rcov=~vs(units, Gtc=fixm(2), Gti=E0scaled),
iters = 1,
data=DT)
mix1$sigma$`u:id`;G0 # should be equal
mix1$sigma$`u:id` + mix1$sigma$`u:units`; P0 # should be equal
# estimated P and G
G <- mix1$sigma$`u:id`
P <- var(DT[,2:3])
mixt1 <- mmer(Yield~1,
random=~vs(id, Gtc=fixm(1),Gti=matrix(G0scaled[1,1])),
rcov=~vs(units, Gtc=fixm(1), Gti=matrix(E0scaled[1,1])),
iters = 1,
data=DT)
mixt2 <- mmer(color~1,
random=~vs(id, Gtc=fixm(1),Gti=matrix(G0scaled[2,2])),
rcov=~vs(units, Gtc=fixm(1), Gti=matrix(E0scaled[2,2])),
iters = 1,
data=DT)
############################################
# ECONOMIC WEIGHTS
w <- c(2,1) # original economic weights
# merit using raw phenotypes multiplied by v = P-Gw
# D*v
merit1 <- pop@pheno %*% smithHazel(w,G0,P0)
# merit using multivariate BLUPs times original weights
# U*w
ids <- as.character(DT$id)
U <- cbind(mix1$U$`u:id`$Yield[ids]+mix1$Beta$Estimate[1],mix1$U$`u:id`$color[ids]+mix1$Beta$Estimate[2])
merit2 <- U %*% w
# compare them, as a result merit  D*v = B*w
plot(merit1,merit2)
d <- sqrt(diag(G0)) # original desired gains (1 standard deviation), response to selection desired
w <- solve(G0)%*%d # desired weights Ginv*d, equivalent to knowing w (economic weights)
# merit using raw phenotypes multiplied by v = P-Gw
# D*v
merit1 <- pop@pheno %*% w # in reality we don't know G0 and phenotype matrix has more than one record per individual, so this is not possible
# merit using multivariate BLUPs times desired weights
# U.dereg*w
ids <- as.character(DT$id)
U <- cbind(mix1$U$`u:id`$Yield[ids]+mix1$Beta$Estimate[1],mix1$U$`u:id`$color[ids]+mix1$Beta$Estimate[2])
U.dereg <- (P0%*%solve(G0)) %*% t(U)
merit2 <- U %*% w
merit3 <- t(U.dereg) %*% w
# compare them, as a result merit  D*v = B*w
plot(merit1,merit2)
plot(merit1,merit3)
U <- cbind(mixt1$U$`u:id`$Yield[ids]+mixt1$Beta$Estimate[1],mixt2$U$`u:id`$color[ids]+mixt2$Beta$Estimate[1])
G0u <- cov(U)
G0u[1,1] <- mixt1$sigma$`u:id`
G0u[2,2] <- mixt2$sigma$`u:id`
G0u
G0u; cov2cor(G0u)
d <- sqrt(diag(G0u)) # original desired gains (1 standard deviation), response to selection desired
w <- solve(G0u)%*%d # desired weights Ginv*d, equivalent to knowing w (economic weights)
# merit using raw phenotypes multiplied by v = P-Gw
# D*v
merit1 <- pop@pheno %*% w # in reality we don't know G0 and phenotype matrix has more than one record per individual, so this is not possible
# merit using multivariate BLUPs times desired weights
# U.dereg*w
ids <- as.character(DT$id)
U.dereg <- (P0%*%solve(G0u)) %*% t(U)
merit2 <- U %*% w
merit3 <- t(U.dereg) %*% w
# compare them, as a result merit  D*v = B*w
plot(merit1,merit2)
plot(merit1,merit3)
setwd("~/Desktop/sommer Extra/TUTORIALS")
save.image(file = "index_comparison.RData")
save(pop, file = "index_comparison.RData")
############################
# real G and P for later use
G0 <- varG(pop)
P0 <- varP(pop)
G0%*%solve(P0) # multivariate heritability
cov2cor(G0)
library(EnvRtype)
## Temperature for a single location:
# tepic 21.5003, -104.8619
dat1 <- get_weather(env.id = "NM", lat = 21.5003, lon = -104.8619, # lat = 19.5242, lon = -98.8122,
start.day = "2000-01-01", end.day = "2020-12-30",
variables.names = c("T2M","T2M_MAX","T2M_MIN","PRECTOT", "WS2M","RH2M","T2MDEW", "ALLSKY_SFC_LW_DWN", "ALLSKY_SFC_SW_DWN"))
dat1$SITE <- "tepic"
dat2 <- get_weather(env.id = "NM", lat = 19.5242, lon = -98.8122,
start.day = "2000-01-01", end.day = "2020-12-30",
variables.names = c("T2M","T2M_MAX","T2M_MIN","PRECTOT", "WS2M","RH2M","T2MDEW", "ALLSKY_SFC_LW_DWN", "ALLSKY_SFC_SW_DWN"))
dat2$SITE <- "texcoco"
dat <- rbind(dat1,dat2)
library(lattice)
##################
## precipitation
head(dat)
response <- "PRECTOT"
ag <- aggregate(as.formula(paste(response,"~MM + YEAR + SITE")), data=dat, FUN=mean)
ag$MMf <- as.factor(ag$MM)
provList <- list()
for(i in 1:12){
prov <- droplevels(ag[which(ag$MM == i),])
prov <- prov[order(prov[,response]), ]
prov$YEARn <- 1:nrow(prov)
provList[[i]] <- prov
}
## Temperature for a single location:
# tepic 21.5003, -104.8619
dat1 <- get_weather(env.id = "NM", lat = 21.5003, lon = -104.8619, # lat = 19.5242, lon = -98.8122,
start.day = "2000-01-01", end.day = "2020-12-30",
variables.names = c("T2M","T2M_MAX","T2M_MIN","PRECTOT", "WS2M","RH2M","T2MDEW", "ALLSKY_SFC_LW_DWN", "ALLSKY_SFC_SW_DWN"))
library(EnvRtype)
## Temperature for a single location:
# tepic 21.5003, -104.8619
dat1 <- get_weather(env.id = "NM", lat = 21.5003, lon = -104.8619, # lat = 19.5242, lon = -98.8122,
start.day = "2000-01-01", end.day = "2020-12-30",
variables.names = c("T2M","T2M_MAX","T2M_MIN","PRECTOT", "WS2M","RH2M","T2MDEW", "ALLSKY_SFC_LW_DWN", "ALLSKY_SFC_SW_DWN"))
install.packages("EnvRtype")
install.packages("sommer")
library(sommer)
?mmer
?overlay
data("DT_halfdiallel")
DT <- DT_halfdiallel
head(DT)
DT$femalef <- as.factor(DT$female)
DT$malef <- as.factor(DT$male)
DT$genof <- as.factor(DT$geno)
A <- diag(7); colnames(A) <- rownames(A) <- 1:7;A # if you want to provide a covariance matrix
#### model using overlay
modh <- mmer(sugar~1,
random=~vs(overlay(femalef,malef), Gu=A)
+ genof,
data=DT)
modh2 <- mmer(sugar~1,
random=~gvs(femalef,malef)
+ genof,
data=DT)
summary(modh)$varcomp
summary(modh2)$varcomp
list2usmat(modh2$sigma[1:3])
cov2cor(list2usmat(modh2$sigma[1:3]))
modh2 <- mmer(sugar~1,
random=~gvs(femalef,malef, Gu=list(A,A))
+ genof,
data=DT)
modh2 <- mmer(sugar~1,
random=~gvs(femalef,malef, Gu=A)
+ genof,
data=DT)
setwd("/Volumes/COVA-USB/CLASSES TAKEN/2016 SPRING/Hort 875 Selection Theory/Natalia's lectures ST/Discussions/Discussion 3/hw2_selectionIndex")
# Read in data
data <- read.csv("HMW2data.csv")
data <- data[,c("Environ", "Rep", "Hybrid", "GY_ba", "GM_pc")]
data$Rep <- as.factor(data$Rep)
head(data)
data(DT_cpdata)
DT <- DT_cpdata
GT <- GT_cpdata
MP <- MP_cpdata
#### create the variance-covariance matrix
A <- A.mat(GT) # additive relationship matrix
library(sommer)
data(DT_cpdata)
DT <- DT_cpdata
GT <- GT_cpdata
MP <- MP_cpdata
#### create the variance-covariance matrix
A <- A.mat(GT) # additive relationship matrix
n <- nrow(DT)
k <- 1
###########################
#### Regular GWAS/EMMAX approach
###########################
mix2 <- GWAS(color~1,
random=~vs(id, Gu=A) + Rowf + Colf,
rcov=~units, M=GT, gTerm = "u:id",
verbose = FALSE,
data=DT)
###########################
#### GWAS by RRBLUP approach
###########################
Z <- GT[as.character(DT$id),]
mixRRBLUP <- mmer(color~1,
random=~vs(Z) + Rowf + Colf,
rcov=~units,
verbose = FALSE,
data=DT)
a <- mixRRBLUP$U$`u:Z`$color # marker effects
a <- mixRRBLUP$U$`u:Z`$color # marker effects
sda <- kronecker(diag(ncol(Z)),mixRRBLUP$sigma$`u:Z`) - mixRRBLUP$PevU$`u:Z`$color
# sda <- sqrt(diag(mixRRBLUP$PevU$`u:Z`$color)) # SD of marker effects
t.stat <- a/sda # t-statistic
pvalRRBLUP <- dt(t.stat,df=n-k-1) # -log10(pval)
###########################
#### GWAS by GBLUP approach
###########################
M<- GT
MMT <-tcrossprod(M) ## MM' = additive relationship matrix
MMTinv<-solve(MMT) ## inverse of MM'
MTMMTinv<-t(M)%*%MMTinv # M' %*% (M'M)-
mixGBLUP <- mmer(color~1,
random=~vs(id, Gu=MMT) + Rowf + Colf,
rcov=~units,
verbose = FALSE,
data=DT)
a.from.g <-MTMMTinv%*%matrix(mixGBLUP$U$`u:id`$color,ncol=1)
varg <- kronecker(MMT,mixGBLUP$sigma$`u:id`) - mixGBLUP$PevU$`u:id`$color
vara.from.g <- t(M)%*%MMTinv%*% (varg) %*% t(MMTinv)%*%M
sda.from.g <- sqrt(diag(vara.from.g))
t.stat.from.g <- a.from.g/sda.from.g # t-statistic
pvalGBLUP <- dt(t.stat.from.g,df=n-k-1) # -log10(pval)
###########################
#### Compare results
###########################
layout(matrix(1:4,2,2))
###########################
#### Compare results
###########################
layout(matrix(1:4,2,2))
plot(mix2$scores[,1], main="GWAS")
plot(-log(pvalRRBLUP), main="GWAS by RRBLUP")
plot(-log(pvalGBLUP), main="GWAS by GBLUP")
a <- mixRRBLUP$U$`u:Z`$color # marker effects
sda <- sqrt(diag(kronecker(diag(ncol(Z)),mixRRBLUP$sigma$`u:Z`) - mixRRBLUP$PevU$`u:Z`$color))
# sda <- sqrt(diag(mixRRBLUP$PevU$`u:Z`$color)) # SD of marker effects
t.stat <- a/sda # t-statistic
pvalRRBLUP <- dt(t.stat,df=n-k-1) # -log10(pval)
###########################
#### Compare results
###########################
layout(matrix(1:4,2,2))
plot(mix2$scores[,1], main="GWAS")
plot(-log(pvalRRBLUP), main="GWAS by RRBLUP")
plot(-log(pvalGBLUP), main="GWAS by GBLUP")
# setwd("~/Desktop/sommer/vignettes")
setwd("~/Desktop/sommer/vignettes")
library(rmarkdown)
library(sommer)
render("v3.sommer.qg.Rmd", pdf_document())
