init = object$sigma_scaled, constraints = object$constraints,
na.method.Y = object$call$na.method.Y,
na.method.X = object$call$na.method.X,...)
}else{
originalModelForMatrices <- mmer(fixed=object$call$fixed,
random=object$call$random,
rcov=object$call$rcov,
data=object$dataOriginal, return.param = TRUE,#reshape.output =FALSE,
init = object$sigma_scaled, constraints = object$constraints,
na.method.Y = object$call$na.method.Y,
na.method.X = object$call$na.method.X,...)
originalModelForParameters <- mmer(fixed=object$call$fixed,
random=object$call$random,
rcov=object$call$rcov,
data=object$dataOriginal, reshape.output =FALSE,
init = object$sigma_scaled, constraints = object$constraints,
na.method.Y = object$call$na.method.Y,
na.method.X = object$call$na.method.X,...)
}
ys <- object$terms$response[[1]]
nt <- length(ys) # number of traits
TT <- diag(nt) # diagonal matrix
Xo <- do.call(cbind,originalModelForMatrices$X)
X.mv.original <- kronecker(Xo,TT)
Xb=X.mv.original%*%originalModelForParameters$Beta
Zu=NULL
if(!is.null(object$call$random)){
nz <- length(originalModelForMatrices$Z)
Zu <- vector(mode = "list", length = nz) # list for Zu
for(ir in 1:nz){ # for each random effect
Z <- originalModelForMatrices$Z[[ir]] # provisional Z
Zu[[ir]] <- kronecker(Z,TT) %*% originalModelForParameters$U[[ir]] # calculate Zu
}
}
if(!is.null(object$call$random)){
y.hat <- Xb + Reduce("+",Zu) # y.hat = Xb + Zu.1 + ... + Zu.n
}else{
y.hat <- Xb # y.hat = Xb
}
# build summary table
nLevels <- c(unlist(lapply(originalModelForMatrices$X,ncol)), unlist(lapply(originalModelForMatrices$Z,ncol)))
namesLevels <- c(unlist(object$terms$fixed),names(object$U))
formLevels <- c(rep("fixed",length(unlist(object$terms$fixed))),rep("random",length(names(object$U))))
id <- 1:length(formLevels)
used <- rep(TRUE,length(id))
fittedSummary <- data.frame(namesLevels,formLevels,nLevels,id,used)
colnames(fittedSummary) <- c("term","type","nLevels","id","used")
return(list(y.hat=y.hat[,1],data=object$dataOriginal,Xb=Xb, Zu=Zu,fittedSummary=fittedSummary))
}
"print.fitted.mmer"<- function(x, digits = max(3, getOption("digits") - 3), ...) {
cat(blue(paste("\n  The fitted values are obtained by adding Xb + Zu.1 + ... + Zu.n
containing: \n")
))
print(x$fittedSummary)
cat(blue(paste("\n  head of fitted values: \n")
))
head(x$data,...)
}
"head.fitted.mmer"<- function(x, digits = max(3, getOption("digits") - 3), ...) {
cat(blue(paste("\n  The fitted values are obtained by adding Xb + Zu.1 + ... + Zu.n
containing: \n")
))
print(x$fittedSummary)
cat(blue(paste("\n  head of fitted values: \n")
))
head(x$data,...)
}
ff=fitted(ans3)
head.fitted.mmer(ff)
print(ff)
print.fitted.mmer(ff)
#### =========== ######
## PREDICT FUNCTION #
#### =========== ######
"fitted.mmer" <- function(object,...){
if(is.null(object$call$random)){
originalModelForMatrices <- mmer(fixed=object$call$fixed,
# random=object$call$random,
rcov=object$call$rcov,
data=object$dataOriginal, return.param = TRUE,#reshape.output =FALSE,
init = object$sigma_scaled, constraints = object$constraints,
na.method.Y = object$call$na.method.Y,
na.method.X = object$call$na.method.X,...)
originalModelForParameters <- mmer(fixed=object$call$fixed,
# random=object$call$random,
rcov=object$call$rcov, iters=1, verbose=FALSE,
data=object$dataOriginal, reshape.output =FALSE,
init = object$sigma_scaled, constraints = object$constraints,
na.method.Y = object$call$na.method.Y,
na.method.X = object$call$na.method.X,...)
}else{
originalModelForMatrices <- mmer(fixed=object$call$fixed,
random=object$call$random,
rcov=object$call$rcov,
data=object$dataOriginal, return.param = TRUE,#reshape.output =FALSE,
init = object$sigma_scaled, constraints = object$constraints,
na.method.Y = object$call$na.method.Y,
na.method.X = object$call$na.method.X,...)
originalModelForParameters <- mmer(fixed=object$call$fixed,
random=object$call$random,
rcov=object$call$rcov, iters=1, verbose=FALSE,
data=object$dataOriginal, reshape.output =FALSE,
init = object$sigma_scaled, constraints = object$constraints,
na.method.Y = object$call$na.method.Y,
na.method.X = object$call$na.method.X,...)
}
ys <- object$terms$response[[1]]
nt <- length(ys) # number of traits
TT <- diag(nt) # diagonal matrix
Xo <- do.call(cbind,originalModelForMatrices$X)
X.mv.original <- kronecker(Xo,TT)
Xb=X.mv.original%*%originalModelForParameters$Beta
Zu=NULL
if(!is.null(object$call$random)){
nz <- length(originalModelForMatrices$Z)
Zu <- vector(mode = "list", length = nz) # list for Zu
for(ir in 1:nz){ # for each random effect
Z <- originalModelForMatrices$Z[[ir]] # provisional Z
Zu[[ir]] <- kronecker(Z,TT) %*% originalModelForParameters$U[[ir]] # calculate Zu
}
}
if(!is.null(object$call$random)){
y.hat <- Xb + Reduce("+",Zu) # y.hat = Xb + Zu.1 + ... + Zu.n
}else{
y.hat <- Xb # y.hat = Xb
}
# build summary table
nLevels <- c(unlist(lapply(originalModelForMatrices$X,ncol)), unlist(lapply(originalModelForMatrices$Z,ncol)))
namesLevels <- c(unlist(object$terms$fixed),names(object$U))
formLevels <- c(rep("fixed",length(unlist(object$terms$fixed))),rep("random",length(names(object$U))))
id <- 1:length(formLevels)
used <- rep(TRUE,length(id))
fittedSummary <- data.frame(namesLevels,formLevels,nLevels,id,used)
colnames(fittedSummary) <- c("term","type","nLevels","id","used")
return(list(y.hat=y.hat[,1],data=object$dataOriginal,Xb=Xb, Zu=Zu,fittedSummary=fittedSummary))
}
"print.fitted.mmer"<- function(x, digits = max(3, getOption("digits") - 3), ...) {
cat(blue(paste("\n  The fitted values are obtained by adding Xb + Zu.1 + ... + Zu.n
containing: \n")
))
print(x$fittedSummary)
cat(blue(paste("\n  head of fitted values: \n")
))
head(x$data,...)
}
"head.fitted.mmer"<- function(x, digits = max(3, getOption("digits") - 3), ...) {
cat(blue(paste("\n  The fitted values are obtained by adding Xb + Zu.1 + ... + Zu.n
containing: \n")
))
print(x$fittedSummary)
cat(blue(paste("\n  head of fitted values: \n")
))
head(x$data,...)
}
ff=fitted(ans3)
head.fitted.mmer(ff)
?matrix
object$terms$response
#### =========== ######
## PREDICT FUNCTION #
#### =========== ######
"fitted.mmer" <- function(object,...){
if(is.null(object$call$random)){
originalModelForMatrices <- mmer(fixed=object$call$fixed,
# random=object$call$random,
rcov=object$call$rcov,
data=object$dataOriginal, return.param = TRUE,#reshape.output =FALSE,
init = object$sigma_scaled, constraints = object$constraints,
na.method.Y = object$call$na.method.Y,
na.method.X = object$call$na.method.X,...)
originalModelForParameters <- mmer(fixed=object$call$fixed,
# random=object$call$random,
rcov=object$call$rcov, iters=1, verbose=FALSE,
data=object$dataOriginal, reshape.output =FALSE,
init = object$sigma_scaled, constraints = object$constraints,
na.method.Y = object$call$na.method.Y,
na.method.X = object$call$na.method.X,...)
}else{
originalModelForMatrices <- mmer(fixed=object$call$fixed,
random=object$call$random,
rcov=object$call$rcov,
data=object$dataOriginal, return.param = TRUE,#reshape.output =FALSE,
init = object$sigma_scaled, constraints = object$constraints,
na.method.Y = object$call$na.method.Y,
na.method.X = object$call$na.method.X,...)
originalModelForParameters <- mmer(fixed=object$call$fixed,
random=object$call$random,
rcov=object$call$rcov, iters=1, verbose=FALSE,
data=object$dataOriginal, reshape.output =FALSE,
init = object$sigma_scaled, constraints = object$constraints,
na.method.Y = object$call$na.method.Y,
na.method.X = object$call$na.method.X,...)
}
ys <- object$terms$response[[1]]
nt <- length(ys) # number of traits
TT <- diag(nt) # diagonal matrix
Xo <- do.call(cbind,originalModelForMatrices$X)
X.mv.original <- kronecker(Xo,TT)
Xb=X.mv.original%*%originalModelForParameters$Beta
Zu=NULL
if(!is.null(object$call$random)){
nz <- length(originalModelForMatrices$Z)
Zu <- vector(mode = "list", length = nz) # list for Zu
for(ir in 1:nz){ # for each random effect
Z <- originalModelForMatrices$Z[[ir]] # provisional Z
Zu[[ir]] <- kronecker(Z,TT) %*% originalModelForParameters$U[[ir]] # calculate Zu
}
}
if(!is.null(object$call$random)){
y.hat <- Xb + Reduce("+",Zu) # y.hat = Xb + Zu.1 + ... + Zu.n
}else{
y.hat <- Xb # y.hat = Xb
}
# realOrder <- list()
# for(i in 1:nt){
#   realOrder[[i]] <- seq(i,length(y.hat[,1]),nt)
# }
# realOrder <- unlist(realOrder)
y.hat.df <- matrix(y.hat[realOrder,1],byrow = TRUE, ncol=nt)
colnames(y.hat.df) <- paste0(object$terms$response[[1]],".fitted")
dataWithFitted <- cbind(object$dataOriginal,y.hat.df)
# build summary table
nLevels <- c(unlist(lapply(originalModelForMatrices$X,ncol)), unlist(lapply(originalModelForMatrices$Z,ncol)))
namesLevels <- c(unlist(object$terms$fixed),names(object$U))
formLevels <- c(rep("fixed",length(unlist(object$terms$fixed))),rep("random",length(names(object$U))))
id <- 1:length(formLevels)
used <- rep(TRUE,length(id))
fittedSummary <- data.frame(namesLevels,formLevels,nLevels,id,used)
colnames(fittedSummary) <- c("term","type","nLevels","id","used")
return(list(dataWithFitted=dataWithFitted,Xb=Xb, Zu=Zu,fittedSummary=fittedSummary))
}
"print.fitted.mmer"<- function(x, digits = max(3, getOption("digits") - 3), ...) {
cat(blue(paste("\n  The fitted values are obtained by adding Xb + Zu.1 + ... + Zu.n
containing: \n")
))
print(x$fittedSummary)
cat(blue(paste("\n  head of fitted values: \n")
))
head(x$dataWithFitted,...)
}
"head.fitted.mmer"<- function(x, digits = max(3, getOption("digits") - 3), ...) {
cat(blue(paste("\n  The fitted values are obtained by adding Xb + Zu.1 + ... + Zu.n
containing: \n")
))
print(x$fittedSummary)
cat(blue(paste("\n  head of fitted values: \n")
))
head(x$dataWithFitted,...)
}
ff=fitted(ans3)
#### =========== ######
## PREDICT FUNCTION #
#### =========== ######
"fitted.mmer" <- function(object,...){
if(is.null(object$call$random)){
originalModelForMatrices <- mmer(fixed=object$call$fixed,
# random=object$call$random,
rcov=object$call$rcov,
data=object$dataOriginal, return.param = TRUE,#reshape.output =FALSE,
init = object$sigma_scaled, constraints = object$constraints,
na.method.Y = object$call$na.method.Y,
na.method.X = object$call$na.method.X,...)
originalModelForParameters <- mmer(fixed=object$call$fixed,
# random=object$call$random,
rcov=object$call$rcov, iters=1, verbose=FALSE,
data=object$dataOriginal, reshape.output =FALSE,
init = object$sigma_scaled, constraints = object$constraints,
na.method.Y = object$call$na.method.Y,
na.method.X = object$call$na.method.X,...)
}else{
originalModelForMatrices <- mmer(fixed=object$call$fixed,
random=object$call$random,
rcov=object$call$rcov,
data=object$dataOriginal, return.param = TRUE,#reshape.output =FALSE,
init = object$sigma_scaled, constraints = object$constraints,
na.method.Y = object$call$na.method.Y,
na.method.X = object$call$na.method.X,...)
originalModelForParameters <- mmer(fixed=object$call$fixed,
random=object$call$random,
rcov=object$call$rcov, iters=1, verbose=FALSE,
data=object$dataOriginal, reshape.output =FALSE,
init = object$sigma_scaled, constraints = object$constraints,
na.method.Y = object$call$na.method.Y,
na.method.X = object$call$na.method.X,...)
}
ys <- object$terms$response[[1]]
nt <- length(ys) # number of traits
TT <- diag(nt) # diagonal matrix
Xo <- do.call(cbind,originalModelForMatrices$X)
X.mv.original <- kronecker(Xo,TT)
Xb=X.mv.original%*%originalModelForParameters$Beta
Zu=NULL
if(!is.null(object$call$random)){
nz <- length(originalModelForMatrices$Z)
Zu <- vector(mode = "list", length = nz) # list for Zu
for(ir in 1:nz){ # for each random effect
Z <- originalModelForMatrices$Z[[ir]] # provisional Z
Zu[[ir]] <- kronecker(Z,TT) %*% originalModelForParameters$U[[ir]] # calculate Zu
}
}
if(!is.null(object$call$random)){
y.hat <- Xb + Reduce("+",Zu) # y.hat = Xb + Zu.1 + ... + Zu.n
}else{
y.hat <- Xb # y.hat = Xb
}
# realOrder <- list()
# for(i in 1:nt){
#   realOrder[[i]] <- seq(i,length(y.hat[,1]),nt)
# }
# realOrder <- unlist(realOrder)
y.hat.df <- matrix(y.hat[,1],byrow = TRUE, ncol=nt)
colnames(y.hat.df) <- paste0(object$terms$response[[1]],".fitted")
dataWithFitted <- cbind(object$dataOriginal,y.hat.df)
# build summary table
nLevels <- c(unlist(lapply(originalModelForMatrices$X,ncol)), unlist(lapply(originalModelForMatrices$Z,ncol)))
namesLevels <- c(unlist(object$terms$fixed),names(object$U))
formLevels <- c(rep("fixed",length(unlist(object$terms$fixed))),rep("random",length(names(object$U))))
id <- 1:length(formLevels)
used <- rep(TRUE,length(id))
fittedSummary <- data.frame(namesLevels,formLevels,nLevels,id,used)
colnames(fittedSummary) <- c("term","type","nLevels","id","used")
return(list(dataWithFitted=dataWithFitted,Xb=Xb, Zu=Zu,fittedSummary=fittedSummary))
}
"print.fitted.mmer"<- function(x, digits = max(3, getOption("digits") - 3), ...) {
cat(blue(paste("\n  The fitted values are obtained by adding Xb + Zu.1 + ... + Zu.n
containing: \n")
))
print(x$fittedSummary)
cat(blue(paste("\n  head of fitted values: \n")
))
head(x$dataWithFitted,...)
}
"head.fitted.mmer"<- function(x, digits = max(3, getOption("digits") - 3), ...) {
cat(blue(paste("\n  The fitted values are obtained by adding Xb + Zu.1 + ... + Zu.n
containing: \n")
))
print(x$fittedSummary)
cat(blue(paste("\n  head of fitted values: \n")
))
head(x$dataWithFitted,...)
}
ff=fitted(ans3)
head.fitted.mmer(ff)
ans3 <- mmer(cbind(Yield,Weight)~Env,
random=~ vs(us(Env),Name),
rcov=~vs(us(Env),units),
data=DT)
ff=fitted(ans3)
head.fitted.mmer(ff)
source('~/Desktop/sommer/R/predict.R')
pp=predict(ans3, classify = "Name")
pp$predictSummary
head(pp)
source('~/Desktop/sommer/R/predict.R')
pp=predict(ans3, classify = "Name")
source('~/Desktop/sommer/R/predict.R')
source('~/Desktop/sommer/R/predict.R')
pp=predict(ans3, classify = "Name")
pp$predictSummary
pp=predict(ans3, classify = "Env")
pp$predictSummary
head(DT)
ans3 <- mmer(cbind(Yield,Weight)~Env,
random=~ vs(us(Env),Name) + Block,
rcov=~vs(us(Env),units),
data=DT)
ans3 <- mmer(cbind(Yield)~Env,
random=~ vs(us(Env),Name) + Block,
rcov=~vs(us(Env),units),
data=DT)
ans3 <- mmer(Yield~Env,
random=~ vs(us(Env),Name) + Block,
rcov=~vs(us(Env),units),
data=DT)
ans3 <- mmer(Yield~Env,
random=~ vs(ds(Env),Name) + Block,
rcov=~vs(us(Env),units),
data=DT)
ans3 <- mmer(Yield~Env,
random=~ Name + Block,
rcov=~vs(us(Env),units),
data=DT)
source('~/Desktop/sommer/R/predict.R')
ans3 <- mmer(Yield~Env,
random=~ Name,
rcov=~vs(us(Env),units),
data=DT)
pp=predict(ans3, classify = "Env")
pp$predictSummary
head(pp)
source('~/Desktop/sommer/R/predict.R')
pp=predict(ans3, classify = "Env")
head(pp)
install.packages("~/Desktop/sommer_4.1.2.tar.gz", repos = NULL, type = "source")
library(sommer)
?spl2D
data(DT_cpdata)
DT <- DT_cpdata
GT <- GT_cpdata
MP <- MP_cpdata
## mimic two fields
aa <- DT; bb <- DT
aa$FIELD <- "A";bb$FIELD <- "B"
set.seed(1234)
aa$Yield <- aa$Yield + rnorm(length(aa$Yield),0,4)
DT2 <- rbind(aa,bb)
head(DT2)
A <- A.mat(GT)
mix <- mmer(Yield~1,
random=~vs(ds(FIELD),id, Gu=A) +
vs(ds(FIELD),Rowf) +
vs(ds(FIELD),Colf) +
vs(ds(FIELD),spl2D(Row,Col)),
rcov=~vs(ds(FIELD),units),
data=DT2)
p0 <- predict.mmer(object=mix, classify = "id")
p0$pvals
head(p0$pvals)
ff=fitted(mix)
source('~/Desktop/sommer/R/FUN_utils.R')
ff=fitted.mmer(mix)
head(ff)
print(ff)
head(ff$dataWithFitted)
p0 <- predict.mmer(object=m3, classify = "B")
pp=predict(ans3, classify = "Env")
ans3 <- mmer(Yield~Env,
random=~ Name,
rcov=~vs(us(Env),units),
data=DT)
data(DT_example)
DT <- DT_example
A <- A_example
head(DT)
ans3 <- mmer(Yield~Env,
random=~ Name,
rcov=~vs(us(Env),units),
data=DT)
summary(ans3)
install.packages("~/Desktop/sommer_4.1.2.tar.gz", repos = NULL, type = "source")
library(sommer)
data(DT_yatesoats)
DT <- DT_yatesoats
m3 <- mmer(fixed=Y ~ V + N + V:N,
random = ~ B + B:MP,
rcov=~units,
data = DT)
summary(m3)$varcomp
p0 <- predict.mmer(object=m3)
p0$pvals
p0 <- predict.mmer(object=m3, classify = "V")
p0$pvals
p0$predictSummary
# setwd("~/Desktop/sommer/vignettes")
setwd("~/Desktop/sommer/vignettes")
library(rmarkdown)
library(sommer)
render("v2.sommer.changes.and.faqs.Rmd", pdf_document())
m3 <- mmer(fixed=Y ~ V + N + V:N,
random = ~ B + B:MP,
rcov=~units,
data = DT)
data(DT_yatesoats)
DT <- DT_yatesoats
m3 <- mmer(fixed=Y ~ V + N + V:N,
random = ~ B + B:MP,
rcov=~units,
data = DT)
summary(m3)$varcomp
object=m3
object=m3
pp <- fitter.mmer(object)
fitter
fitted
pp <- fitted.mmer(object)
object$terms$response[[1]]
responses <- object$terms$response[[1]]
dat <- pp$dataWithFitted
head(pp$dataWithFitted)
source('~/Desktop/sommer/R/FUN_utils.R')
ff <- fitted.mmer(m3)
head(ff$dataWithFitted)
rr <- residuals.mmer(m3)
head(rr)
plot(rr$Y.fitted,rr$Y)
?mmer
install.packages("~/Desktop/sommer_4.1.2.tar.gz", repos = NULL, type = "source")
library(sommer)
m3 <- mmer(fixed=Y ~ V + N + V:N,
random = ~ B + B:MP,
rcov=~units,
data = DT)
data(DT_yatesoats)
DT <- DT_yatesoats
m3 <- mmer(fixed=Y ~ V + N + V:N,
random = ~ B + B:MP,
rcov=~units,
data = DT)
summary(m3)$varcomp
p0 <- predict.mmer(object=m3)
p0$pvals
p0 <- predict.mmer(object=m3, classify = "V")
p0$pvals
p0$predictSummary
head(p0)
ff <- fitted(m3)
ff$fittedSummary
rr <- residuals(m3)
head(rr)
?mmer
?sommer
?sommer
